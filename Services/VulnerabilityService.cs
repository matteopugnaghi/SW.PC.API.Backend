// üõ°Ô∏è Vulnerability Scanner Service - EU CRA Compliance
// Scans SBOM dependencies against vulnerability databases (OSV, GitHub, NVD, ENISA)

using System.Diagnostics;
using System.Text.Json;
using System.Text.Json.Serialization;
using SW.PC.API.Backend.Models;

namespace SW.PC.API.Backend.Services;

/// <summary>
/// Interface for vulnerability scanning
/// </summary>
public interface IVulnerabilityService
{
    /// <summary>Get scanner status and last scan summary</summary>
    Task<VulnerabilityScanStatus> GetStatusAsync();
    
    /// <summary>Perform a full vulnerability scan</summary>
    Task<VulnerabilityScanResult> ScanAsync();
    
    /// <summary>Get detailed list of vulnerabilities from last scan</summary>
    Task<List<Vulnerability>> GetVulnerabilitiesAsync();
    
    /// <summary>Check if scanner is enabled</summary>
    bool IsEnabled { get; }
}

/// <summary>
/// Vulnerability Scanner Service - Queries CVE databases for known vulnerabilities
/// </summary>
public class VulnerabilityService : IVulnerabilityService
{
    private readonly ILogger<VulnerabilityService> _logger;
    private readonly IConfiguration _configuration;
    private readonly ISbomService _sbomService;
    private readonly IExcelConfigService _excelConfigService;
    private readonly HttpClient _httpClient;
    
    // Configuration - loaded dynamically from Excel
    private string _apiUrl = "";
    private string _apiType = "OSV";
    private string _apiKey = "";
    private bool _alertOnCritical = true;
    private int _intervalHours = 0;
    
    // Cache of last scan
    private VulnerabilityScanResult? _lastScanResult;
    private readonly string _cacheFilePath;
    
    // JSON options
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        PropertyNameCaseInsensitive = true,
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    };

    public VulnerabilityService(
        ILogger<VulnerabilityService> logger,
        IConfiguration configuration,
        ISbomService sbomService,
        IExcelConfigService excelConfigService,
        IHttpClientFactory httpClientFactory)
    {
        _logger = logger;
        _configuration = configuration;
        _sbomService = sbomService;
        _excelConfigService = excelConfigService;
        _httpClient = httpClientFactory.CreateClient("VulnerabilityScanner");
        
        // Cache file path
        var contentRoot = configuration["ContentRootPath"] ?? Directory.GetCurrentDirectory();
        _cacheFilePath = Path.Combine(contentRoot, "wwwroot", "sbom", "vulnerability-scan-cache.json");
        
        // Load cached results
        LoadCachedResults();
        
        // Load configuration from Excel (async in background)
        _ = LoadConfigurationAsync();
        
        _logger.LogInformation("üõ°Ô∏è VulnerabilityService initialized");
    }

    /// <summary>
    /// Load configuration from Excel via ExcelConfigService
    /// </summary>
    private async Task LoadConfigurationAsync()
    {
        try
        {
            // Try to find Excel file
            var possiblePaths = new[]
            {
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "ExcelConfigs", "ProjectConfig.xlsm"),
                Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "..", "..", "..", "ExcelConfigs", "ProjectConfig.xlsm"),
                @"C:\Users\mpugnaghi.AQUAFRISCH\Documents\Work_In_Process\_Web\AI test\SW.PC.API.Backend_\ExcelConfigs\ProjectConfig.xlsm"
            };
            
            var excelPath = possiblePaths.FirstOrDefault(File.Exists);
            
            if (excelPath != null)
            {
                var systemConfig = await _excelConfigService.LoadSystemConfigurationAsync(excelPath);
                
                _apiUrl = systemConfig.VulnScanApiUrl ?? "";
                _apiType = systemConfig.VulnScanApiType ?? "OSV";
                _apiKey = systemConfig.VulnScanApiKey ?? "";
                _alertOnCritical = systemConfig.VulnScanAlertOnCritical;
                _intervalHours = systemConfig.VulnScanIntervalHours;
                
                _logger.LogInformation("üõ°Ô∏è VulnerabilityService config loaded from Excel. Enabled: {Enabled}, API: {ApiType}, URL: {Url}", 
                    IsEnabled, _apiType, MaskUrl(_apiUrl));
            }
            else
            {
                // Fallback to appsettings.json
                _apiUrl = _configuration["SystemConfig:VulnScanApiUrl"] ?? "";
                _apiType = _configuration["SystemConfig:VulnScanApiType"] ?? "OSV";
                _apiKey = _configuration["SystemConfig:VulnScanApiKey"] ?? "";
                _alertOnCritical = _configuration.GetValue<bool>("SystemConfig:VulnScanAlertOnCritical", true);
                _intervalHours = _configuration.GetValue<int>("SystemConfig:VulnScanIntervalHours", 0);
                
                _logger.LogWarning("üõ°Ô∏è VulnerabilityService: Excel not found, using appsettings.json. Enabled: {Enabled}", IsEnabled);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "üõ°Ô∏è Error loading vulnerability scanner config from Excel");
        }
    }

    /// <summary>
    /// Is the scanner enabled (has API URL configured)?
    /// </summary>
    public bool IsEnabled => !string.IsNullOrWhiteSpace(_apiUrl);

    /// <summary>
    /// Get current scanner status
    /// </summary>
    public async Task<VulnerabilityScanStatus> GetStatusAsync()
    {
        // Ensure config is loaded
        if (string.IsNullOrEmpty(_apiUrl) && string.IsNullOrEmpty(_apiType))
        {
            await LoadConfigurationAsync();
        }
        
        var status = new VulnerabilityScanStatus
        {
            IsEnabled = IsEnabled,
            ApiType = _apiType,
            ApiUrlMasked = MaskUrl(_apiUrl),
            ScanIntervalHours = _configuration.GetValue<int>("SystemConfig:VulnScanIntervalHours", 0)
        };

        if (!IsEnabled)
        {
            status.Status = "disabled";
            status.StatusMessage = "Vulnerability scanner not configured. Set VulnScanApiUrl in Excel.";
            return status;
        }

        if (_lastScanResult != null)
        {
            status.LastScanDate = _lastScanResult.ScanDate;
            status.PackagesScanned = _lastScanResult.PackagesScanned;
            status.TotalVulnerabilities = _lastScanResult.Vulnerabilities.Count;
            status.CriticalCount = _lastScanResult.Vulnerabilities.Count(v => v.Severity == VulnSeverity.Critical);
            status.HighCount = _lastScanResult.Vulnerabilities.Count(v => v.Severity == VulnSeverity.High);
            status.MediumCount = _lastScanResult.Vulnerabilities.Count(v => v.Severity == VulnSeverity.Medium);
            status.LowCount = _lastScanResult.Vulnerabilities.Count(v => v.Severity == VulnSeverity.Low);
            
            // Determine status
            if (status.CriticalCount > 0)
            {
                status.Status = "critical";
                status.StatusMessage = $"{status.CriticalCount} critical vulnerabilities found!";
            }
            else if (status.HighCount > 0)
            {
                status.Status = "warning";
                status.StatusMessage = $"{status.HighCount} high severity vulnerabilities found";
            }
            else if (status.TotalVulnerabilities > 0)
            {
                status.Status = "warning";
                status.StatusMessage = $"{status.TotalVulnerabilities} vulnerabilities found";
            }
            else
            {
                status.Status = "ok";
                status.StatusMessage = "No known vulnerabilities detected";
            }
            
            // Next scheduled scan
            if (status.ScanIntervalHours > 0 && status.LastScanDate.HasValue)
            {
                status.NextScheduledScan = status.LastScanDate.Value.AddHours(status.ScanIntervalHours);
            }
        }
        else
        {
            status.Status = "unknown";
            status.StatusMessage = "No scan performed yet. Click SCAN to check for vulnerabilities.";
        }

        return status;
    }

    /// <summary>
    /// Perform full vulnerability scan
    /// </summary>
    public async Task<VulnerabilityScanResult> ScanAsync()
    {
        // Ensure config is loaded
        if (string.IsNullOrEmpty(_apiUrl))
        {
            await LoadConfigurationAsync();
        }
        
        var stopwatch = Stopwatch.StartNew();
        var result = new VulnerabilityScanResult();
        
        if (!IsEnabled)
        {
            result.Success = false;
            result.Message = "Vulnerability scanner not configured. Set VulnScan_ApiUrl in Excel System Config.";
            return result;
        }

        _logger.LogInformation("üõ°Ô∏è Starting vulnerability scan using {ApiType} API at {Url}...", _apiType, MaskUrl(_apiUrl));

        try
        {
            // Get SBOM
            var sbom = await _sbomService.GetSbomAsync();
            if (sbom == null || sbom.Components.Count == 0)
            {
                result.Success = false;
                result.Message = "No SBOM available. Generate SBOM first.";
                return result;
            }

            result.PackagesScanned = sbom.Components.Count;
            _logger.LogInformation("üì¶ Scanning {Count} packages...", sbom.Components.Count);

            // Scan based on API type
            var vulnerabilities = _apiType.ToUpperInvariant() switch
            {
                "OSV" => await ScanWithOsvAsync(sbom.Components),
                "GITHUB" => await ScanWithGitHubAsync(sbom.Components),
                // "NVD" => await ScanWithNvdAsync(sbom.Components),
                // "ENISA" => await ScanWithEnisaAsync(sbom.Components),
                _ => await ScanWithOsvAsync(sbom.Components) // Default to OSV
            };

            result.Vulnerabilities = vulnerabilities;
            result.Success = true;
            result.Message = vulnerabilities.Count > 0 
                ? $"Found {vulnerabilities.Count} vulnerabilities" 
                : "No known vulnerabilities detected";

            stopwatch.Stop();
            result.ScanDuration = stopwatch.Elapsed;
            result.ScanDate = DateTime.UtcNow;

            // Update status
            result.Status = new VulnerabilityScanStatus
            {
                IsEnabled = true,
                ApiType = _apiType,
                LastScanDate = result.ScanDate,
                PackagesScanned = result.PackagesScanned,
                TotalVulnerabilities = vulnerabilities.Count,
                CriticalCount = vulnerabilities.Count(v => v.Severity == VulnSeverity.Critical),
                HighCount = vulnerabilities.Count(v => v.Severity == VulnSeverity.High),
                MediumCount = vulnerabilities.Count(v => v.Severity == VulnSeverity.Medium),
                LowCount = vulnerabilities.Count(v => v.Severity == VulnSeverity.Low)
            };

            // Cache results
            _lastScanResult = result;
            await SaveCachedResultsAsync();

            _logger.LogInformation("üõ°Ô∏è Vulnerability scan completed in {Duration}ms. Found: {Critical} critical, {High} high, {Medium} medium, {Low} low",
                stopwatch.ElapsedMilliseconds,
                result.Status.CriticalCount,
                result.Status.HighCount,
                result.Status.MediumCount,
                result.Status.LowCount);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå Vulnerability scan failed");
            result.Success = false;
            result.Message = $"Scan failed: {ex.Message}";
            result.Errors.Add(ex.Message);
        }

        return result;
    }

    /// <summary>
    /// Get vulnerabilities from last scan
    /// </summary>
    public Task<List<Vulnerability>> GetVulnerabilitiesAsync()
    {
        return Task.FromResult(_lastScanResult?.Vulnerabilities ?? new List<Vulnerability>());
    }

    // ==================== OSV API Implementation ====================

    private async Task<List<Vulnerability>> ScanWithOsvAsync(List<SbomComponent> components)
    {
        var vulnerabilities = new List<Vulnerability>();

        foreach (var component in components)
        {
            try
            {
                // Determine ecosystem
                var ecosystem = DetermineEcosystem(component);
                if (string.IsNullOrEmpty(ecosystem)) continue;

                var query = new OsvQueryRequest
                {
                    Package = new OsvPackage
                    {
                        Name = component.Name,
                        Ecosystem = ecosystem
                    },
                    Version = component.Version
                };

                var json = JsonSerializer.Serialize(query, JsonOptions);
                var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");
                
                var response = await _httpClient.PostAsync(_apiUrl, content);
                
                if (response.IsSuccessStatusCode)
                {
                    var responseJson = await response.Content.ReadAsStringAsync();
                    var osvResponse = JsonSerializer.Deserialize<OsvQueryResponse>(responseJson, JsonOptions);
                    
                    if (osvResponse?.Vulns != null)
                    {
                        foreach (var vuln in osvResponse.Vulns)
                        {
                            vulnerabilities.Add(MapOsvToVulnerability(vuln, component));
                        }
                    }
                }
                else
                {
                    _logger.LogWarning("OSV API returned {StatusCode} for {Package}", 
                        response.StatusCode, component.Name);
                }

                // Rate limiting - be nice to the API
                await Task.Delay(100);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to check {Package} against OSV", component.Name);
            }
        }

        return vulnerabilities;
    }

    private Vulnerability MapOsvToVulnerability(OsvVulnerability osv, SbomComponent component)
    {
        var vuln = new Vulnerability
        {
            Id = osv.Id ?? "UNKNOWN",
            Summary = osv.Summary ?? "No summary available",
            Details = osv.Details,
            AffectedPackage = component.Name,
            InstalledVersion = component.Version,
            Ecosystem = DetermineEcosystem(component),
            PublishedDate = osv.Published,
            ModifiedDate = osv.Modified,
            Aliases = osv.Aliases ?? new List<string>()
        };

        // Parse severity
        if (osv.severity != null && osv.severity.Count > 0)
        {
            var severityItem = osv.severity.FirstOrDefault();
            if (severityItem?.score != null && double.TryParse(
                severityItem.score.Split(':').LastOrDefault()?.Replace(".", ","), 
                out var cvss))
            {
                vuln.CvssScore = cvss;
                vuln.Severity = cvss switch
                {
                    >= 9.0 => VulnSeverity.Critical,
                    >= 7.0 => VulnSeverity.High,
                    >= 4.0 => VulnSeverity.Medium,
                    > 0 => VulnSeverity.Low,
                    _ => VulnSeverity.Unknown
                };
            }
        }

        // Parse affected versions and fixed version
        if (osv.Affected != null)
        {
            var affected = osv.Affected.FirstOrDefault();
            if (affected?.Ranges != null)
            {
                var range = affected.Ranges.FirstOrDefault();
                if (range?.Events != null)
                {
                    var fixedEvent = range.Events.FirstOrDefault(e => e.Fixed != null);
                    if (fixedEvent != null)
                    {
                        vuln.FixedVersion = fixedEvent.Fixed;
                    }
                }
            }
        }

        // Parse references
        if (osv.References != null)
        {
            vuln.References = osv.References
                .Where(r => !string.IsNullOrEmpty(r.Url))
                .Select(r => r.Url!)
                .ToList();
        }

        return vuln;
    }

    // ==================== GitHub API Implementation ====================

    private async Task<List<Vulnerability>> ScanWithGitHubAsync(List<SbomComponent> components)
    {
        // GitHub Advisory API implementation
        // Similar to OSV but uses GraphQL or REST API
        _logger.LogWarning("GitHub Advisory API not fully implemented yet, falling back to OSV");
        return await ScanWithOsvAsync(components);
    }

    // ==================== Helper Methods ====================

    private string DetermineEcosystem(SbomComponent component)
    {
        // Check PURL first
        if (!string.IsNullOrEmpty(component.Purl))
        {
            if (component.Purl.StartsWith("pkg:nuget/")) return "NuGet";
            if (component.Purl.StartsWith("pkg:npm/")) return "npm";
            if (component.Purl.StartsWith("pkg:pypi/")) return "PyPI";
        }

        // Check group/type
        if (!string.IsNullOrEmpty(component.Group))
        {
            if (component.Group.Equals("nuget", StringComparison.OrdinalIgnoreCase)) return "NuGet";
            if (component.Group.Equals("npm", StringComparison.OrdinalIgnoreCase)) return "npm";
        }

        // Guess based on name patterns
        if (component.Name.Contains('.') && !component.Name.Contains('/'))
            return "NuGet"; // Likely NuGet (Microsoft.Extensions.*, etc.)
        
        if (component.Name.StartsWith("@") || component.Name.Contains('/'))
            return "npm"; // Likely npm (@babel/*, react-*, etc.)

        return ""; // Unknown ecosystem
    }

    private string MaskUrl(string url)
    {
        if (string.IsNullOrEmpty(url)) return "";
        try
        {
            var uri = new Uri(url);
            return $"{uri.Scheme}://{uri.Host}/***";
        }
        catch
        {
            return "***configured***";
        }
    }

    private void LoadCachedResults()
    {
        try
        {
            if (File.Exists(_cacheFilePath))
            {
                var json = File.ReadAllText(_cacheFilePath);
                _lastScanResult = JsonSerializer.Deserialize<VulnerabilityScanResult>(json, JsonOptions);
                _logger.LogInformation("üìÇ Loaded cached vulnerability scan from {Date}", 
                    _lastScanResult?.ScanDate);
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not load cached vulnerability scan");
        }
    }

    private async Task SaveCachedResultsAsync()
    {
        try
        {
            var directory = Path.GetDirectoryName(_cacheFilePath);
            if (!string.IsNullOrEmpty(directory))
            {
                Directory.CreateDirectory(directory);
            }
            
            var json = JsonSerializer.Serialize(_lastScanResult, JsonOptions);
            await File.WriteAllTextAsync(_cacheFilePath, json);
            _logger.LogDebug("üíæ Saved vulnerability scan cache");
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Could not save vulnerability scan cache");
        }
    }
}
